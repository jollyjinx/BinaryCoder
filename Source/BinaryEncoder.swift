
import Foundation


/// A protocol for types which can be encoded to binary.
public protocol BinaryEncodable: Encodable {
    func binaryEncode(to encoder: Encoder) throws
}

extension BinaryEncodable where Self: Collection, Self.Element: BinaryEncodable {
    public func encodeWithFixedSize(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: _FixedCodingKey.self)
        for (index, item) in self.enumerated() {
            let key = _FixedCodingKey(intValue: index)!
            try container.encode(item, forKey: key)
        }
    }
}


/// Provide a default implementation which calls through to `Encodable`. This
/// allows `BinaryEncodable` to use the `Encodable` implementation generated by the
/// compiler.
public extension BinaryEncodable {
    func binaryEncode(to encoder: Encoder) throws {
        try self.encode(to: encoder)
    }
}

/// The actual binary encoder class.
public class BinaryEncoder {
    
    open var includeStingLengthPrefix: Bool = true
    
    /// All errors which can happen during encoding.
    enum Error: Swift.Error {
        /// Attempted to encode a type which is `Encodable`, but not `BinaryEncodable`. (We
        /// require `BinaryEncodable` because `BinaryEncoder` doesn't support full keyed
        /// coding functionality.)
        case typeNotConformingToBinaryEncodable(Encodable.Type)
        
        /// Attempted to encode a type which is not `Encodable`.
        case typeNotConformingToEncodable(Any.Type)
        
        /// Attempted to encode a `UInt32` which can't be represented. Because the
        /// length can't be represented with `UInt32`
        case lengthOutOfRange(UInt64)
        
        case containerTypeNotImplemented
        case unknowObjectType
    }
    
    /// Options set on the top-level encoder to pass down the encoding hierarchy.
    fileprivate struct _Options {
        let includeStingLengthPrefix: Bool
    }
    
    /// The options set on the top-level encoder.
    fileprivate var options: _Options {
        return _Options(includeStingLengthPrefix: includeStingLengthPrefix)
    }
    
    public init() {}
    
    open func encode<T : BinaryEncodable>(_ encodable: T) throws -> [UInt8] {
        let encoder = _BinaryEncoder(options: self.options)
        guard let encoded = try encoder.box_(encodable) as? BinaryContainer else {
            throw EncodingError.invalidValue(encodable,
                                             EncodingError.Context(codingPath: [], debugDescription: "Top-level \(T.self) did not encode any values."))
        }
        
        do {
            let element = try BinarySerialiazation.dataArray(with: encoded)
            return element
        } catch {
            throw EncodingError.invalidValue(encodable,
                                             EncodingError.Context(codingPath: [], debugDescription: "Unable to encode the given top-level value to JSON.", underlyingError: error))
        }
    }
}

/// Methods for encoding various types.
private class _BinaryEncoder: Encoder {
    
    var storage: _BinaryEncodingStorage
    
    /// Options set on the top-level encoder.
    let options: BinaryEncoder._Options
    
    public var codingPath: [CodingKey]
    
    // TODO: Add from options
    public var userInfo: [CodingUserInfoKey : Any] { return [:] }
    
    init(options: BinaryEncoder._Options, codingPath: [CodingKey] = []) {
        self.options = options
        self.codingPath = codingPath
        self.storage = _BinaryEncodingStorage()
    }
    
    /// Returns whether a new element can be encoded at this coding path.
    ///
    /// `true` if an element has not yet been encoded at this coding path; `false` otherwise.
    var canEncodeNewValue: Bool {
        // Every time a new value gets encoded, the key it's encoded for is pushed onto the coding path (even if it's a nil key from an unkeyed container).
        // At the same time, every time a container is requested, a new value gets pushed onto the storage stack.
        // If there are more values on the storage stack than on the coding path, it means the value is requesting more than one container, which violates the precondition.
        //
        // This means that anytime something that can request a new container goes onto the stack, we MUST push a key onto the coding path.
        // Things which will not request containers do not need to have the coding path extended for them (but it doesn't matter if it is, because they will not reach here).
        return self.storage.count == self.codingPath.count
    }
    
    public func container<Key>(keyedBy type: Key.Type) -> KeyedEncodingContainer<Key> where Key : CodingKey {
        // If an existing keyed container was already requested, return that one.
        let topContainer: BinaryContainer
        if self.canEncodeNewValue {
            // We haven't yet pushed a container at this level; do so here.
            topContainer = self.storage.pushKeyedContainer()
        } else {
            guard let container = self.storage.containers.last as? BinaryContainer, container.type == .fixed else {
                preconditionFailure("Attempt to push new keyed encoding container when already previously encoded at this path.")
            }

            topContainer = container
        }

        let container = _BinaryKeyedEncodingContainer<Key>(referencing: self, codingPath: self.codingPath, wrapping: topContainer)
        return KeyedEncodingContainer(container)
    }
    
    public func unkeyedContainer() -> UnkeyedEncodingContainer {
        // If an existing unkeyed container was already requested, return that one.
        let topContainer: BinaryContainer
        if self.canEncodeNewValue {
            // We haven't yet pushed a container at this level; do so here.
            topContainer = self.storage.pushUnkeyedContainer()
        } else {
            guard let container = self.storage.containers.last as? BinaryContainer, container.type == .variable() else {
                preconditionFailure("Attempt to push new unkeyed encoding container when already previously encoded at this path.")
            }

            topContainer = container
        }

        return _BinaryUnkeyedEncodingContainer(referencing: self, codingPath: self.codingPath, wrapping: topContainer)
    }
    
    public func singleValueContainer() -> SingleValueEncodingContainer {
        return self
    }
    
}

// MARK: - Encoding Storage and Containers

fileprivate struct _BinaryEncodingStorage {
    // MARK: Properties

    /// The container stack.
    /// Elements can be only BinaryContainer.
    private(set) fileprivate var containers: [AnyByteContainer] = []

    // MARK: - Initialization

    /// Initializes `self` with no containers.
    fileprivate init() {}

    // MARK: - Modifying the Stack

    fileprivate var count: Int {
        return self.containers.count
    }

    fileprivate mutating func pushKeyedContainer() -> BinaryContainer {
        let dictionary = BinaryContainer(type: .fixed)
        self.containers.append(dictionary)
        return dictionary
    }

    fileprivate mutating func pushUnkeyedContainer() -> BinaryContainer {
        let array = BinaryContainer(type: .variable())
        self.containers.append(array)
        return array
    }

    fileprivate mutating func push(container: __owned AnyByteContainer) {
        self.containers.append(container)
    }

    fileprivate mutating func popContainer() -> AnyByteContainer {
        precondition(!self.containers.isEmpty, "Empty container stack.")
        return self.containers.popLast()!
    }
}

private struct _BinaryKeyedEncodingContainer<Key: CodingKey>: KeyedEncodingContainerProtocol {
    
    // MARK: Properties
    
    /// A reference to the encoder we're writing to.
    var encoder: _BinaryEncoder
    
    /// A reference to the container we're writing to.
    var container: BinaryContainer
    
    /// The path of coding keys taken to get to this point in encoding.
    private(set) public var codingPath: [CodingKey]
    
    // MARK: - Initialization
    
    /// Initializes `self` with the given references.
    init(referencing encoder: _BinaryEncoder, codingPath: [CodingKey], wrapping container: BinaryContainer) {
        self.encoder = encoder
        self.codingPath = codingPath
        self.container = container
    }
    
    func encodeNil(forKey key: Key) throws {}
    
    public mutating func encode(_ value: Bool, forKey key: Key)      throws  { self.container.add(self.encoder.box(value)) }
    
    public mutating func encode(_ value: Float, forKey key: Key)     throws  { self.container.add(self.encoder.box(value)) }
    public mutating func encode(_ value: Double, forKey key: Key)    throws  { self.container.add(self.encoder.box(value)) }
    
    public mutating func encode(_ value: Int, forKey key: Key)       throws  { self.container.add(self.encoder.box(value)) }
    public mutating func encode(_ value: UInt, forKey key: Key)      throws  { self.container.add(self.encoder.box(value)) }
    
    public mutating func encode(_ value: Int8, forKey key: Key)      throws  { self.container.add(self.encoder.box(value)) }
    public mutating func encode(_ value: Int16, forKey key: Key)     throws  { self.container.add(self.encoder.box(value)) }
    public mutating func encode(_ value: Int32, forKey key: Key)     throws  { self.container.add(self.encoder.box(value)) }
    public mutating func encode(_ value: Int64, forKey key: Key)     throws  { self.container.add(self.encoder.box(value)) }
    public mutating func encode(_ value: UInt8, forKey key: Key)     throws  { self.container.add(self.encoder.box(value)) }
    public mutating func encode(_ value: UInt16, forKey key: Key)    throws  { self.container.add(self.encoder.box(value)) }
    public mutating func encode(_ value: UInt32, forKey key: Key)    throws  { self.container.add(self.encoder.box(value)) }
    public mutating func encode(_ value: UInt64, forKey key: Key)    throws  { self.container.add(self.encoder.box(value)) }
    
    public mutating func encode<T>(_ value: T, forKey key: Key) throws where T : Encodable {
        self.encoder.codingPath.append(key)
        defer { self.encoder.codingPath.removeLast() }
        
        let encoded = try self.encoder.box(value)
        self.container.add(encoded)
    }
    
    public mutating func nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type, forKey key: Key) -> KeyedEncodingContainer<NestedKey> where NestedKey : CodingKey {
        let dictionary: BinaryContainer = BinaryContainer(type: .fixed)
        self.container.add(dictionary)
        
        self.codingPath.append(key)
        defer { self.codingPath.removeLast() }

        let container = _BinaryKeyedEncodingContainer<NestedKey>(referencing: self.encoder, codingPath: self.codingPath, wrapping: dictionary)
        return KeyedEncodingContainer(container)
    }
    
    public mutating func nestedUnkeyedContainer(forKey key: Key) -> UnkeyedEncodingContainer {
        let array: BinaryContainer = BinaryContainer(type: .variable())
        
        self.container.add(array)

        self.codingPath.append(key)
        defer { self.codingPath.removeLast() }
        return _BinaryUnkeyedEncodingContainer(referencing: self.encoder, codingPath: self.codingPath, wrapping: array)
    }
    
    func superEncoder() -> Encoder {
        fatalError("superEncoder() not implemented")
    }
    
    func superEncoder(forKey key: Key) -> Encoder {
        fatalError("superEncoder(forKey key:) not implemented")
    }
}

private struct _BinaryUnkeyedEncodingContainer: UnkeyedEncodingContainer {
    // MARK: Properties
    
    /// A reference to the encoder we're writing to.
    private let encoder: _BinaryEncoder
    
    /// A reference to the container we're writing to.
    private let container: BinaryContainer
    
    /// The path of coding keys taken to get to this point in encoding.
    private(set) public var codingPath: [CodingKey]
    
    /// The number of elements encoded into the container.
    public var count: Int {
        return self.container.count
    }
    
    // MARK: - Initialization

    /// Initializes `self` with the given references.
    init(referencing encoder: _BinaryEncoder, codingPath: [CodingKey], wrapping container: BinaryContainer) {
        self.encoder = encoder
        self.codingPath = codingPath
        self.container = container
    }
    
    // MARK: - UnkeyedEncodingContainer Methods
    
    func encodeNil() throws {}
    
    public mutating func encode(_ value: String) throws {
        self.container.add(try self.encoder.box(value))
    }
    
    public mutating func encode(_ value: Bool) throws {
        self.container.add(self.encoder.box(value))
        self.container.incrementSize(1)
    }
    
    public mutating func encode(_ value: Float) throws {
        self.container.add(self.encoder.box(value))
        self.container.incrementSize(1)
    }
    
    public mutating func encode(_ value: Double) throws {
        self.container.add(self.encoder.box(value))
        self.container.incrementSize(1)
    }
    
    public mutating func encode(_ value: Int) throws {
        self.container.add(self.encoder.box(value))
        self.container.incrementSize(1)
    }
    
    public mutating func encode(_ value: UInt) throws {
        self.container.add(self.encoder.box(value))
        self.container.incrementSize(1)
    }
    
    public mutating func encode(_ value: Int8) throws {
        self.container.add(self.encoder.box(value))
        self.container.incrementSize(1)
    }
    
    public mutating func encode(_ value: Int16) throws {
        self.container.add(self.encoder.box(value))
        self.container.incrementSize(1)
    }
    
    public mutating func encode(_ value: Int32) throws {
        self.container.add(self.encoder.box(value))
        self.container.incrementSize(1)
    }
    
    public mutating func encode(_ value: Int64) throws {
        self.container.add(self.encoder.box(value))
        self.container.incrementSize(1)
    }
    
    public mutating func encode(_ value: UInt8) throws {
        self.container.add(self.encoder.box(value))
        self.container.incrementSize(1)
    }
    
    public mutating func encode(_ value: UInt16) throws {
        self.container.add(self.encoder.box(value))
        self.container.incrementSize(1)
    }
    
    public mutating func encode(_ value: UInt32) throws {
        self.container.add(self.encoder.box(value))
        self.container.incrementSize(1)
    }
    
    public mutating func encode(_ value: UInt64) throws {
        self.container.add(self.encoder.box(value))
        self.container.incrementSize(1)
    }
    
    public mutating func encode<T>(_ value: T) throws where T : Encodable {
        self.encoder.codingPath.append(_BinaryKey(index: self.count))
        defer { self.encoder.codingPath.removeLast() }
        self.container.add(try self.encoder.box(value))
        self.container.incrementSize(1)
    }
    
    /*
    mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence {
        
    }
     */
    
    public mutating func nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type) -> KeyedEncodingContainer<NestedKey> where NestedKey : CodingKey {
        self.codingPath.append(_BinaryKey(index: self.count))
        defer { self.codingPath.removeLast() }

        let dictionary = BinaryContainer(type: .fixed)
        self.container.add(dictionary)

        let container = _BinaryKeyedEncodingContainer<NestedKey>(referencing: self.encoder, codingPath: self.codingPath, wrapping: dictionary)
        return KeyedEncodingContainer(container)
    }
    
    public mutating func nestedUnkeyedContainer() -> UnkeyedEncodingContainer {
        self.codingPath.append(_BinaryKey(index: self.count))
        defer { self.codingPath.removeLast() }

        let array = BinaryContainer(type: .variable())
        self.container.add(array)
        return _BinaryUnkeyedEncodingContainer(referencing: self.encoder, codingPath: self.codingPath, wrapping: array)
    }
    
    func superEncoder() -> Encoder {
        fatalError("superEncoder() not implemented")
    }
}

extension _BinaryEncoder: SingleValueEncodingContainer {
    // MARK: - SingleValueEncodingContainer Methods

    private func assertCanEncodeNewValue() {
        precondition(self.canEncodeNewValue, "Attempt to encode value through single value container when previously value already encoded.")
    }
    
    func encodeNil() throws {}
    
    public func encode(_ value: Bool) throws {
        assertCanEncodeNewValue()
        self.storage.push(container: self.box(value))
    }
    
    public func encode(_ value: Float) throws {
        assertCanEncodeNewValue()
        self.storage.push(container: self.box(value))
    }
    
    public func encode(_ value: Double) throws {
        assertCanEncodeNewValue()
        self.storage.push(container: self.box(value))
    }
    
    public func encode(_ value: Int) throws {
        assertCanEncodeNewValue()
        self.storage.push(container: self.box(value))
    }
    
    public func encode(_ value: UInt) throws {
        assertCanEncodeNewValue()
        self.storage.push(container: self.box(value))
    }
    
    public func encode(_ value: Int8) throws {
        assertCanEncodeNewValue()
        self.storage.push(container: self.box(value))
    }
    
    public func encode(_ value: Int16) throws {
        assertCanEncodeNewValue()
        self.storage.push(container: self.box(value))
    }
    
    public func encode(_ value: Int32) throws {
        assertCanEncodeNewValue()
        self.storage.push(container: self.box(value))
    }
    
    public func encode(_ value: Int64) throws {
        assertCanEncodeNewValue()
        self.storage.push(container: self.box(value))
    }
    
    public func encode(_ value: UInt8) throws {
        assertCanEncodeNewValue()
        self.storage.push(container: self.box(value))
    }
    
    public func encode(_ value: UInt32) throws {
        assertCanEncodeNewValue()
        self.storage.push(container: self.box(value))
    }
    
    public func encode(_ value: UInt64) throws {
        assertCanEncodeNewValue()
        self.storage.push(container: self.box(value))
    }
    
    func encode<T>(_ value: T) throws where T : Encodable {
        assertCanEncodeNewValue()
        try self.storage.push(container: self.box(value))
    }
    
    
}

// MARK: - Concrete Value Representations

extension _BinaryEncoder {
    
    func box(_ value: Bool)     -> AnyByteContainer { return getBytes(of: value ? 1 as UInt8 : 0 as UInt8) }
    
    func box(_ value: Float)    -> AnyByteContainer { return getBytes(of: value) }
    func box(_ value: Double)   -> AnyByteContainer { return getBytes(of: value) }
    
    func box(_ value: Int)      -> AnyByteContainer { return box(Int64(value)) }
    func box(_ value: UInt)     -> AnyByteContainer { return box(UInt64(value)) }
    
    func box(_ value: Int8)     -> AnyByteContainer { return getBytes(of: value.littleEndian) }
    func box(_ value: Int16)    -> AnyByteContainer { return getBytes(of: value.littleEndian) }
    func box(_ value: Int32)    -> AnyByteContainer { return getBytes(of: value.littleEndian) }
    func box(_ value: Int64)    -> AnyByteContainer { return getBytes(of: value.littleEndian) }
    func box(_ value: UInt8)    -> AnyByteContainer { return getBytes(of: value.littleEndian) }
    func box(_ value: UInt16)   -> AnyByteContainer { return getBytes(of: value.littleEndian) }
    func box(_ value: UInt32)   -> AnyByteContainer { return getBytes(of: value.littleEndian) }
    func box(_ value: UInt64)   -> AnyByteContainer { return getBytes(of: value.littleEndian) }
    
    func box<T : Encodable>(_ value: T) throws -> AnyByteContainer {
        if let binary = value as? BinaryEncodable {
            let result: AnyByteContainer
            if let fixedSize = value as? FixedSizeData {
                result = try self.boxFixed_(fixedSize.data) ?? []
            } else {
                result = try self.box_(binary) ?? []
            }
            return result
        } else {
            throw BinaryEncoder.Error.typeNotConformingToBinaryEncodable(type(of: value))
        }
    }
    
    func boxFixed_<T: BinaryEncodable & Collection>(_ value: T) throws -> AnyByteContainer? where T.Element: BinaryEncodable {
            
        // The value should request a container from the _BinaryEncoder.
        let depth = self.storage.count
        do {
            try value.encodeWithFixedSize(to: self)
        } catch {
            // If the value pushed a container before throwing, pop it back off to restore state.
            if self.storage.count > depth {
                let _ = self.storage.popContainer()
            }

            throw error
        }

        // The top container should be a new container.
        guard self.storage.count > depth else {
            return nil
        }
        
        return self.storage.popContainer()
    }
    
    func box_(_ value: BinaryEncodable) throws -> AnyByteContainer? {
            
        // The value should request a container from the _BinaryEncoder.
        let depth = self.storage.count
        do {
            try value.binaryEncode(to: self)
        } catch {
            // If the value pushed a container before throwing, pop it back off to restore state.
            if self.storage.count > depth {
                let _ = self.storage.popContainer()
            }

            throw error
        }

        // The top container should be a new container.
        guard self.storage.count > depth else {
            return nil
        }
        
        return self.storage.popContainer()
    }
    
    /// Append the raw bytes of the parameter to the encoder's data. No byte-swapping
    /// or other encoding is done.
    func getBytes<T>(of: T) -> [UInt8] {
        let target = of
        let buffer = withUnsafeBytes(of: target) {
            return $0
        }
        return [UInt8].init(buffer)
    }
}
